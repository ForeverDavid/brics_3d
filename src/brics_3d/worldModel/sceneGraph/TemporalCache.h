/******************************************************************************
* BRICS_3D - 3D Perception and Modeling Library
* Copyright (c) 2013, KU Leuven
*
* Author: Sebastian Blumenthal
*
*
* This software is published under a dual-license: GNU Lesser General Public
* License LGPL 2.1 and Modified BSD license. The dual-license implies that
* users of this code may choose which terms they prefer.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License LGPL and the BSD license for
* more details.
*
******************************************************************************/

#ifndef BRICS_3D_TEMPORALCACHE_H_
#define BRICS_3D_TEMPORALCACHE_H_

#include "TimeStamp.h"
#include "brics_3d/core/Logger.h"
#include <vector>

using brics_3d::Logger;

namespace brics_3d {

namespace rsg {

/**
 * @brief A generic temporal cache.
 *
 * Example usage:
 *
 * @code
 *
 *  TemporalCache<int> cache(TimeStamp(20, Units::Second)); // cache size = 20[s]
 *
 *  // Note: in real aplications the time stamps will be generated by a timer
 *  // but for demonstration purposes we will use manually defined time stamps.
 *
 *  cache.insertData(1, TimeStamp(0, Units::Second));    // entry has a value of 1
 *  cache.insertData(2, TimeStamp(10.0, Units::Second)); // entry has a value of 2
 *  cache.insertData(3, TimeStamp(15.0, Units::Second)); // entry has a value of 3
 *
 *  int result;
 *  result = cache.getData(TimeStamp(0, Units::Second)));   // result = 1
 *  result = cache.getData(TimeStamp(4, Units::Second)));   // result = 1
 *  result = cache.getData(TimeStamp(5, Units::Second)));   // result = 2; equal distance to 0 and 10 -> the newer one will be selected
 *  result = cache.getData(TimeStamp(10, Units::Second)));  // result = 2
 *  result = cache.getData(TimeStamp(12, Units::Second)));  // result = 2
 *  result = cache.getData(TimeStamp(12.5, Units::Second)));// result = 3; equal distance to 10 and 15 -> the newer one will be selected
 *  result = cache.getData(TimeStamp(15, Units::Second)));  // result = 3
 *  result = cache.getData(TimeStamp(30, Units::Second)));  // result = 3; beyond cache limit -> still the latest entry will be returnd
 *
 *  // The caches can be also acessed via iterators:
 *  typedef std::vector<std::pair<int, TimeStamp> >::const_iterator IntCacheIterator; // Note that cache has decending order: The older, the closer to the end.
 *  for (IntCacheIterator iterator = cache.begin(); iterator!=cache.end(); ++iterator) {
 *  	std::cout << "iterator (value, stamp): (" << iterator->first << "," << iterator->second.getSeconds() << ")" << std::endl;
 *  	//iterator->first = 42; // does not work because access is read-only
 *  }
 *
 *  typedef std::vector<std::pair<int, TimeStamp> >::const_reverse_iterator IntCacheReverseIterator; // Go through values in ascending order.
 *  for (IntCacheReverseIterator iterator = cache.rbegin(); iterator!=cache.rend(); ++iterator) {
 *  	std::cout << "reverse iterator (value, stamp): (" << iterator->first << "," << iterator->second.getSeconds() << ")" << std::endl;
 *  }
 *
 * @endcode
 *
 * The resulting output would be:
 *
 * @verbatim

  iterator (value, stamp): (3,15)
  iterator (value, stamp): (2,10)
  iterator (value, stamp): (1,0)
  reverse iterator (value, stamp): (1,0)
  reverse iterator (value, stamp): (2,10)
  reverse iterator (value, stamp): (3,15)

   @endverbatim
 *
 */
template<typename T>
class TemporalCache {
public:

	/**
	 * @brief Constructor for a the temporal cache with optional cache size parameter.
	 * @param maxHistoryDuration Size of the cache. Default value is 10[s].
	 * In case of an invalid input, that is a negative value, it will be set to a duration of 0[s].
	 */
	TemporalCache(TimeStamp maxHistoryDuration = TimeStamp(10.0, Units::Second)) {
		this->setMaxHistoryDuration(maxHistoryDuration);
		history.clear();
	}

	/**
	 * @brief Default destructor.
	 */
	virtual ~TemporalCache(){
		history.clear();
	}

	/**
	 * @brief Insert a new time stamped data into the cache.
	 *
	 * The cache makes sure that all values are sorted by time stamps in descending order.
	 * That means "the older the closer to the end".
	 * Insertions will cause deletions of old values that are beyond the time window.
	 * The window is defined by the latest timestamp and the latest time stamp in the cache
	 * minus the maxHistoryDuration (cache size).
	 *
	 * It is possible that the freshly inserted data will be immediately deleted in case that
	 * it is too outdated.
	 *
	 * As long as deleteOutdatedData() is not called externally (which is possible) there will be always
	 * one elemet in the cache after the first insertion. However the entry might be rather old.
	 *
	 * It is possible to keep the temporal cache "aligned" with the current system time if
	 * deleteOutdatedData() is triggered periodically with the current system time. In this
	 * case the cache might get flushed completely.
	 *
	 * @param newData The new datum to be inserted. The actual type is defined by the template parameter.
	 * @param timeStamp The accompanying time stamp. It will define the position.
	 */
    void insertData(T newData, TimeStamp timeStamp) {

    	/* history policy: descending order of timestamps (the older the closer to the end - like humans...)
    	 *  latest              oldest
    	 *   |-------------------|
    	 *  begin               end
    	 */

    	historyIterator = history.begin();

    	/* insert new data at its correct place in time */
    	while(historyIterator != history.end()) { // loop over history
    		if (historyIterator->second <= timeStamp) {
    			break;
    		}
    		historyIterator++;
    	}
    	history.insert(historyIterator, std::make_pair(newData, timeStamp)); // fit into correct temporal place


    	/*
    	 * Clean up outdated data.
    	 * In this case the temporal reference is deduced from the stored data and not
    	 * from the current (real) time.
    	 */
    	historyIterator = history.begin(); // we already know that there is already one element...
    	TimeStamp latestTimeStamp = history.begin()->second;
    	deleteOutdatedData(latestTimeStamp);
    }

    /**
     * @brief Retrive data from the cache given a time stamp.
     *
     * The "best fitting" cache entry will be returned. The means the entry whose time
     * stamp is closest will be picked. Even if the query reaches beyond the cache limits.
     * I.e. a query older then the oldest entry will return the oldest entry in the cache.
     * Queries that are newer then the latest entry will return the latest one. There is
     * no interpolation of data.
     *
     * To check how far a query is beyond the cache limits, use the getLatestTimeStamp() or
     * getOldestTimeStamp() functions.
     *
     * @param timeStamp Based on tis time stamp a value will be returned.
     * @return Returns the best fitting cache entry. The actual type is defined by the template parameter.
     */
    T getData(TimeStamp timeStamp) {
    	typename std::vector<std::pair<T, TimeStamp> >::iterator closestTransform = getClosestData(timeStamp);
    	if(closestTransform == history.end()) {
    		LOG(WARNING) << "TemporalCache is empty. Cannot find data for time stamp at "  << timeStamp.getSeconds() << " [s]";
//    		return 0;
    		return returnNullData();
    	}
    	return closestTransform->first;
    }

    /**
     * @brief Get a read-only iterator in descending order at the beginning of the cache (latest).
     * @return Iteratror
     */
    typename std::vector<std::pair<T, TimeStamp> >::const_iterator begin() {
    	return history.begin();
    }

    /**
     * @brief Get a read-only iterator in descending order at the end of the cache (oldest).
     * @return Iteratror
     */
    typename std::vector<std::pair<T, TimeStamp> >::const_iterator end() {
    	return history.end();
    }

    /**
     * @brief Get a read-only iterator in ascending order at the beginning of the cache (oldest).
     * This is probably the iterator that will be used in most applications.
     * @return Iteratror
     */
    typename std::vector<std::pair<T, TimeStamp> >::const_reverse_iterator rbegin() {
    	return history.rbegin();
    }

    /**
     * @brief Get a read-only iterator in ascending order at the beginning of the cache (latest).
     * This is probably the iterator that will be used in most applications.
     * @return Iteratror
     */
    typename std::vector<std::pair<T, TimeStamp> >::const_reverse_iterator rend() {
    	return history.rend();
    }


    /**
     * @brief Getter for maxHistoryDuration.
     */
    TimeStamp getMaxHistoryDuration() {
    	return maxHistoryDuration;
    }

    /**
     * @brief Setter for maxHistoryDuration.
     *
     * Negative values for time will be ignored.
     */
    void setMaxHistoryDuration(TimeStamp maxHistoryDuration) {
    	if (maxHistoryDuration >= TimeStamp(0.0, Units::Second)) {
    		this->maxHistoryDuration = maxHistoryDuration;
    	} else {
    		LOG(ERROR) << "Cannot set negative duration of "<< maxHistoryDuration.getSeconds() <<"[s] for the temporal cache. Ignoring it.";
    	}
    }

    /**
     * @brief Returns the number of elements that are stored in the history cache.
     */
    unsigned int getNumberOfCacheEntries() {
    	return static_cast<unsigned int>(history.size());
    }

    /**
     * @brief Get the latest time stamp that is in the history cache.
     * @return The latest time stamp or 0.0 in case of an empty history cache.
     */
    TimeStamp getLatestTimeStamp() {
    	typename std::vector<std::pair<T, TimeStamp> >::iterator historyIterator = history.begin();
    	if(historyIterator == history.end()) {
    		LOG(WARNING) << "The TemporalCache is empty. Returning TimeStamp(0.0) instead.";
    		return TimeStamp(0.0);
    	}
    	return history.front().second;
    }

    /**
     * @brief Get the oldest time stamp that is in the history cache.
     * @return The oldest time stamp or 0.0 in case of an empty history cache.
     */
    TimeStamp getOldestTimeStamp() {
    	typename std::vector<std::pair<T, TimeStamp> >::iterator historyIterator = history.begin();
    	if(historyIterator == history.end()) {
    		LOG(WARNING) << "The TemporalCache is empty. Returning TimeStamp(0.0) instead.";
    		return TimeStamp(0.0);
    	}
    	return history.back().second;
    }

    /**
     * @brief Completely flush the cache.
     */
    void clear() {
    	history.clear();
    }

    /**
     * @brief Delete all data from the history/cache that is older than the latestTimeStamp minus the duration of maxHistoryDuration.
     * @param latestTimeStamp The time stamp the defines the "current" time. To this stamp the maximim duration will relate.
     *        Plase note that in case that you do not pass the timeStamp from the history cache via getLatestTimeStamp() the complete history might
     *        get earased! Use the function outside the scope of this class with care.
     */
    void deleteOutdatedData(TimeStamp latestTimeStamp) {
    	/*
    	 * delete all data where the durartion (delta between latestTime and stored) exeeds
    	 * the defined maximum history duration
    	 */
    	while(!history.empty() && (history.back().second + maxHistoryDuration < latestTimeStamp)) {
    		history.pop_back();
    	}
    }

protected:
    /// Data cache. Each data T has an associated time stamp.
    std::vector<std::pair<T, TimeStamp> > history;

    /// Iterator for the cache entries.
    typename std::vector<std::pair<T, TimeStamp> >::iterator historyIterator;

    /// Size of the cache.
    TimeStamp maxHistoryDuration; //TODO: should be of some Duration type not a time stamp...

    /**
     * @brief Determine the position in the history cache whose time stamp matches best a given stamp.
     * @param timeStamp Time stamp to wich the temporal closest data shall be found.
     * @return Iterator to the transform with closest time stamp. In case timeStamp is exactly in between
     * two times stamps of the cache the latest of both will be taken.
     */
    typename std::vector<std::pair<T, TimeStamp> >::iterator getClosestData(TimeStamp timeStamp) {

    	typename std::vector<std::pair<T, TimeStamp> >::iterator resultIterator;
    	typename std::vector<std::pair<T, TimeStamp> >::iterator previousIterator; //remember: values have a decending order
    	resultIterator = history.begin();

    	if(getNumberOfCacheEntries() == 1) { // special case for first element -> just return it
    		return resultIterator;
    	}

    	while(resultIterator != history.end()) { // loop over history
    		if (timeStamp >= resultIterator->second) {
    			if(resultIterator != history.begin()) { // i.e. a previous element exists => coMpare wich is actually the closest
    				previousIterator = resultIterator - 1;
    				if ( (previousIterator->second - timeStamp) <= (timeStamp - resultIterator->second) ) {
    					return previousIterator;
    				} else {
    					return resultIterator;
    				}
    			} else {
    				return resultIterator;
    			}
    		}
    		resultIterator++;
    	}

    	/*
    	 * We might reach this line when timeStamp is older thant the oldest element in the history.
    	 * In that case we want to return the last/oldest element.
    	 */
    	if(getNumberOfCacheEntries() > 1) {
    		resultIterator = history.end() - 1;
    		assert(timeStamp < resultIterator->second); // just to be sure...
    	}
    	return resultIterator;
    }

    /**
     * @brief Return a "null value".
     *
     * There might be further spacializations for this as "null value"
     * might differ from type to type. E.g. More complex types might
     * need to return some sort of null object.
     *
     * @return Null
     */
    T returnNullData() {
    	return 0;
    }
};

}

}

#endif /* BRICS_3D_TEMPORALCACHE_H_ */

/* EOF */
